# Глава 1: Обработка изображений <br> Раздел 2: Основные манипуляции с изображением

## 8. Изменение размеров изображения путем обрезки или заполнения

[Обрезка](#81-обрезка-заданной-области-изображения) позволяет создать новое изображение из выбранной части большего размера.
[Заполнение](#84-расширение-изображения-на-границах) обычно используется для [расширения изображения на границах](#84-расширение-изображения-на-границах), чтобы обеспечить равномерную обработку граничных пикселей во многих задачах обработки изображений.

### 8.1 Обрезка заданной области изображения

|функция|описание|
|:-|:-|
|[ImageTake](https://reference.wolfram.com/language/ref/ImageTake.html?q=ImageTake)[*image*, *n*]|возвращает [первые *n* рядов](#первые-200-строчек) *image*|
|[ImageTake](https://reference.wolfram.com/language/ref/ImageTake.html?q=ImageTake)[*image*, *-n*]|возвращает [последние *n* рядов](#последние-100-строчек) *image*|
|[ImageTake](https://reference.wolfram.com/language/ref/ImageTake.html?q=ImageTake)[*image*, *row<sub>1</sub>*, *row<sub>2</sub>*]|возвращает ряды *image* [между *row<sub>1</sub>* и *row<sub>2</sub>*](#строчки-от-100-до-200)|
|[ImageTake](https://reference.wolfram.com/language/ref/ImageTake.html?q=ImageTake)[*image*, {*row<sub>1</sub>*, *row<sub>2</sub>*}, {*col<sub>1</sub>*, *col<sub>2</sub>*}]|возвращает [часть](#строчки-от-30-до-100-колонки-от-260-до-130) *image* ограниченную *row<sub>1</sub>* и *row<sub>2</sub>* по вертикали и *col<sub>1</sub>* и *col<sub>2</sub>* по горизонтали|
|[ImageTake](https://reference.wolfram.com/language/ref/ImageTake.html?q=ImageTake)[*image3D*, {*slice<sub>1</sub>*, *slice<sub>2</sub>*}, {*row<sub>1</sub>*, *row<sub>2</sub>*}, {*col<sub>1</sub>*, *col<sub>2</sub>*}]|возврящяет [часть](#часть-в-3d-объёме) 3D изображения *image3D* в виде нового 3D изображения, состоящего из сечения *slice*, ограниченного рядами *rows* и колонками *cols*|

#### Детализация:

<img align = 'center' style = 'max-width:200px' src = 'img/2/81a1.png' /> $\Rrightarrow$ <img align = 'center' style = 'max-width:200px' src = 'img/2/81a2.png' />

[ImageTake](#81-обрезка-заданной-области-изображения) использует [стандартную спецификацию последовательностей]().
<!---(стандартную спецификацию последовательносте). сделать ссылку-->
При испольховании стандартных [параметров](#padding), если размер исходного изображения меньше чем укаано в аргументах, возвращается лишь существующая часть искходного изображения (размер полученого изображения будет меньше чем указано в аргументах).

#### Примеры:

`ImageTake[`<img align = 'center' style = 'max-width:200px' src = 'img/2/81b1.png' />`, All, {220, 700}]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81b2.png' />

##### обрезка 2D-изображения:

`im = `<img align = 'center' style = 'max-width:200px' src = 'img/2/81c1.png' />;

###### первые 200 строчек:

    ImageTake[im, 200]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81c2.png' />

###### последние 100 строчек:

    ImageTake[im, -100]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81c3.png' />

###### строчки от 100 до 200:

    ImageTake[im, {100, 200}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81c4.png' />

###### строчки от 30 до 100; колонки от 260 до 130:

    ImageTake[im, {30, 100}, {260, 330}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81c5.png' />

###### 100я строчка:

    ImageTake[im, {100}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81c6.png' />

###### строчки c 1 по последнюю через 5:

    ImageTake[im, {1, -1, 5}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81c7.png' />

###### столбцы с 1 по 300:

    ImageTake[im, All, 300]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81c8.png' />

    ImageTake[im, {230, 330}, {200, 300}](*строчки 230-330, столбцы 200-300*)

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81c9.png' />

##### обрезка 3D-изображения:

`im3D = `<img align = 'center' style = 'max-width:200px' src = 'img/2/81d1.png' />

    ImageDimensions[im3D]

`Out[]:`

    {256, 256, 99}

###### верхние 80 слоёв:

    ImageTake[im3D, 80]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81d2.png' />

###### нижние 80 слоёв:

    ImageTake[im3D, -80]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81d3.png' />

###### 45й слой:

    ImageTake[im3D, {45}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81d4.png' />

###### все слои в указанной области:

    ImageTake[im3D, All, -150, -150]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81d5.png' />

###### часть в 3D объёме

    ImageTake[im3D, {30, 80}, {215, 256}, {80, 130}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81d6.png' />

###### Интерактивное изменение выделения вырезаемых фрагментов.

    im3DDims = ImageDimensions[im3D]
    Manipulate[ImageTake[im3D, {s1, s2}, {r1, r2}, {c1, c2}], {r1, 1, im3DDims[[1]]}, {r2, 1, im3DDims[[1]]}, {c1, 1, im3DDims[[2]]}, {c2, 1, im3DDims[[2]]}, {s1, 1, im3DDim[[3]]}, {s2, 1, im3DDims[[3]]}]
`Out[1]:`

    {256, 256, 99}

`Out[2]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81d7.png' />

#### Применение:

##### Нахождение интересующей области (в координатах), выделение ее на исходном изображении и обрезка:

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/81e1.png' />;

    ImageDimensions[i]

`Out[]:`

    {251, 201}

---

    {x, y} = Round[MinMax /@ Transpose[ImageKeypoints[i, KeypointStrength -> 0.0001]]]
    HighlightImage[i, Rectangle @@ Transpose[{x, y}]]
    ImageTake[i, Sort[201 - y], Sort[x]]

`Out[1]:`

    {{29, 169}, {88, 142}}

`Out[2]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81e2.png' />

`Out[3]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/81e3.png' />

#### Взаимосвязь с другими WM-функциями:

|функция|аналог|описание|
|:-|:-|:-|
|[ImageReflect](https://reference.wolfram.com/language/ref/ImageReflect.html?q=ImageReflect)[*image*]|[ImageTake](#81-обрезка-заданной-области-изображения)[*image*, {-1, 1}]|переворот изображения *image*|<!--ImageReflect-->
|[Downsample](https://reference.wolfram.com/language/ref/Downsample.html?q=Downsample)[*image*, *k*]|[ImageTake](#81-обрезка-заданной-области-изображения)[*image*, {1, -1, *k*}, {1, -1, *k*}]|понижение дискретизации *image* путём возвращения каждого *k*-нного пикселя|<!--Downsample-->

`im = `<img align = 'center' style = 'max-width:200px' src = 'img/2/81f1.png' />

    {ImageReflect[im], ImageTake[im, {-1, 1}]}

`Out[]:` {<img align = 'center' style = 'max-width:200px' src = 'img/2/81f2.png' />, <img align = 'center' style = 'max-width:200px' src = 'img/2/81f3.png' />}

    {Downsample[im, 3], ImageTake[im, {1, -1, 3}, {1, -1, 3}]}

`Out[]:` {<img align = 'center' style = 'max-width:200px' src = 'img/2/81f4.png' />, <img align = 'center' style = 'max-width:200px' src = 'img/2/81f5.png' />}

### 8.2 Удаление граничных пикселей из изображения

|функция|описание|
|:-|:-|
|[ImageCrop](https://reference.wolfram.com/language/ref/ImageCrop.html?q=ImageCrop)[*image*]|[обрезка](#примеры-вариантов-обрезки-изображения-результатов-тонкослойной-хроматографии) *image* путем удаления границ однородного цвета|
|[ImageCrop](https://reference.wolfram.com/language/ref/ImageCrop.html?q=ImageCrop)[*image*, *size*]|[обрезка](#тонкослойная-хроматография-2) *image* по заданным границам [*size*](#size-1) со всех сторон|
|[ImageCrop](https://reference.wolfram.com/language/ref/ImageCrop.html?q=ImageCrop)[*image*, *size*, *side*]|[обрезка](#примеры-вариантов-обрезки-изображения-результатов-тонкослойной-хроматографии) *image* по заданным границам [*size*](#size-1) со сторон заданных [*side*](#side-1)|

[ImageCrop](#82-удаление-граничных-пикселей-из-изображения) дополняет [ImageTake](#81-обрезка-заданной-области-изображения). Эта функция используется для удаления ненужных или извлечения интересующих областей.
Эффективно удаляет из изображения границы, распределение значений пикселей которых почти однородно.

#### обрезка фона, на котором сфотографирован мазок крови:

`ImageCrop[`<img align = 'center' style = 'max-width:200px' src = 'img/2/82a1.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/82a2.png' />

#### Детализация и опции:
[1]

При выполнении [функции](#82-удаление-граничных-пикселей-из-изображения) указывается [количество](#size-параметры) строк и/или столбцов относительно центра изображения, которые должны быть сохранены.
По умолчанию пиксели срхраняются [симметрично](#side-параметры).

<img align = 'center' style = 'max-width:200px' src = 'img/2/82b1.png' /> $\Rightarrow$ <img align = 'center' style = 'max-width:200px' src = 'img/2/82b2.png' />

##### size-параметры:

<div id = 'size-1'></div>

- size-параметры
    |параметр|описание|
    |:-|:-|
    |*width*|[конкретная](#тонкослойная-хроматография-2) ширина и пропорциональная высота|
    |{*width*, *height*}|[конкретные](#тонкослойная-хроматография-3) ширина и высота|
    |{*width*, *depth*, *height*}|конкретные ширина, глубина и высота для 3D-изображений|
    |*width*{1, r}|получить изображение с соотношением сторон r|
- возможные значенмя
    |значение|описание|
    |:-|:-|
    |*d*|*d* [пикселей](#тонкослойная-хроматография-2)|
    |[UpTo](https://reference.wolfram.com/language/ref/UpTo.html?q=UpTo)[*d*]|максимум *d* [пикселей](#тонкослойная-хроматография-перевёрнутая)|
    |{*d<sub>min</sub>*, *d<sub>max</sub>*}|область пикселей |
    |[Automatic](https://reference.wolfram.com/language/ref/Automatic.html?q=Automatic)|автоматическое пропорциональное [значение](#тонкослойная-хроматография-5)|
    |[Full](https://reference.wolfram.com/language/ref/Full.html?q=Full)|не делать [обрезку](#тонкослойная-хроматография-4) в этом измерении|

##### side-параметры:

<div id = 'side-1'></div>

- side-параметры
    |параметр|описание|
    |:-|:-|
    |*side*|[обрезка](#тонкослойная-хроматография-6) стороны *side* и центрирование по противоположной|
    |{*side<sub>1</sub>*, *side<sub>2</sub>*}|[обрезка](#тонкослойная-хроматография-9) сторон side<sub>n</sub>|
    |{*a<sub>x</sub>*, *b<sub>y</sub>*}|доли [обрезки](#тонкослойная-хроматография-7) каждой стороны|
- возможные значения
    |значение|описание|
    |:-|:-|
    |[Left](https://reference.wolfram.com/language/ref/Left.html?q=Left)|[обрезка](#то) левой стороны|
    |[Right](https://reference.wolfram.com/language/ref/Right.html?q=Right)|[обрезка](#тонкослойная-хроматография-9) правой стороны|
    |[Bottom](https://reference.wolfram.com/language/ref/Bottom.html?q=Bottom)|обрезка нижней стороны|
    |[Top](https://reference.wolfram.com/language/ref/Top.html?q=Top)|[обрезка](#обрезка-верхних-23-слоёв) верхней стороны|
    |[Center](https://reference.wolfram.com/language/ref/Center.html?q=Center)|[обрезка](#тонкослойная-хроматография-9) симметрично всех сторон|

#### Примеры:

##### примеры вариантов обрезки изображения результатов тонкослойной хроматографии:

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/82c1.png' />

###### тонкослойная хроматография 1:

    ImageCrop[i]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/82c2.png' />

###### тонкослойная хроматография 2:

    ImageCrop[i, 200]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/82c3.png' />

###### тонкослойная хроматография 3:

    ImageCrop[i, {200, 200}]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/82c4.png' />

###### тонкослойная хроматография 4:

    ImageCrop[i, {200, Full}]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/82c5.png' />


###### тонкослойная хроматография 5:

    ImageCrop[i, {Automatic, 200}]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/82c6.png' />

###### тонкослойная хроматография 6:

    ImageCrop[i, 180, Left]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/82c7.png' />

###### тонкослойная хроматография 7:

    ImageCrop[i, 180, {-1, 0}],

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/82c8.png' />

###### тонкослойная хроматография 8:

    ImageCrop[i, 180, {-.5, 0}]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/82c9.png' />

###### тонкослойная хроматография 9:

    ImageCrop[i, 150, {Right, Center}]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/82c10.png' />

###### тонкослойная хроматография перевёрнутая:

    ImageCrop[ImageRotate[i], UpTo[290]]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/82c11.png' />

##### обрезка 3D-изображения:

`im3D = `<img align = 'center' style = 'max-width:200px' src = 'img/2/82d1.png' />

    ImageDimensions[im3D]

`Out[]:`

    {46, 46, 46}

###### обрезка верхних 23 слоёв:

    ImageCrop[im3D, {Full, Full, 23}, Top]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/82d2.png' />

###### горизонтальное сечение:

    ImageCrop[i, {Full, Full, 1}, {0, 0, 0.5}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/82d3.png' />

###### обрезка заданного объёма:

    ImageCrop[i, {23, 23, Full}, {-1, 1, 1}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/82d4.png' />

#### Опции:

<div id = 'padding-82'></div>

##### [Padding](<!--Padding-->):

Если указанная для удаления ширина или высота больше, чем само изображение, создаётся буфер путём добавления пикселей симметрично или в соответствии с настройкой [Padding](<!--Padding-->) 
<!---(раздел Общие опции). сделать ссылку-->

`{ImageCrop[`<img align = 'center' style = 'max-width:200px' src = 'img/2/82e1.png' />`, 400], ImageCrop[`<img align = 'center' style = 'max-width:200px' src = 'img/2/82e1.png' />`, 400, Padding -> Automatic]}`

`Out[]: {`<img align = 'center' style = 'max-width:200px' src = 'img/2/82e2.png' />, <img align = 'center' style = 'max-width:200px' src = 'img/2/82e3.png' />`}`

###### примеры использования [Padding](#padding-82):

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/82f1.png' />

    {ImageCrop[i, 500], ImageCrop[i, 500, Padding -> Red], ImageCrop[i, {500, Full}, Padding -> Green]}

`Out[]:` {<img align = 'center' style = 'max-width:200px' src = 'img/2/82f2.png' />, <img align = 'center' style = 'max-width:200px' src = 'img/2/82f3.png' />, <img align = 'center' style = 'max-width:200px' src = 'img/2/82f4.png' />}

###### зеркальное отражение [Padding](#padding-82):

    {ImageCrop[i, 500, Padding -> "Fixed"], ImageCrop[i, 500, Padding -> "Reflected"]}

`Out[]: {`<img align = 'center' style = 'max-width:200px' src = 'img/2/82f5.png' />, <img align = 'center' style = 'max-width:200px' src = 'img/2/82f6.png' />`}`

###### Сравнение результатов с опцией [Padding](#padding-82) и без

<!--Padding-->

При использовании опции `Padding -> None` размер получаемого изображения может быть меньше исходного.

<!--Padding-->

    ImageCrop[i, {500, Full}]
    ImageDimensions[%]
    ImageCrop[i, {500, Full}, Padding -> None]
    ImageDimensions[%]

`Out[1]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/82f7.png' />

`Out[2]: {500, 312}`

`Out[3]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/82f8.png' />

`Out[4]: {416, 312}`

#### Приминение:

##### обрезка рамки:

Обрезка рамки происходит, если она присутствует по крайней мере с двух сторон.

`{ImageCrop[`<img align = 'center' style = 'max-width:200px' src = 'img/2/82g1.png' />`], ImageCrop[`<img align = 'center' style = 'max-width:200px' src = 'img/2/82g2.png' />`]}`

`Out[]: {`<img align = 'center' style = 'max-width:200px' src = 'img/2/82g3.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img/2/82g4.png' />`}`

### 8.3 Извлечение областей из изображения

|функция|описание|
|:-|:-|
|[ImageTrim](https://reference.wolfram.com/language/ref/ImageTrim.html?q=ImageTrim)[*image*, *roi*]|из *image* [вырезается](#вырезка-области-изображения-по-заданным-координатам) меньшее изображение, так, чтобы оно включало в себя область интереса [*roi*](#roi-83)|
|[ImageTrim](https://reference.wolfram.com/language/ref/ImageTrim.html?q=ImageTrim)[*image*, *roi*, *r*]|из *image* [вырезается](#margin-83) меньшее изображение, так, чтобы оно включало в себя область интереса [*roi*](#roi-83) и окружающий его марджин (запас) размера [*r*](#r-83)|
|[ImageTrim](https://reference.wolfram.com/language/ref/ImageTrim.html?q=ImageTrim)[image, {*roi<sub>1</sub>*, *roi<sub>2</sub>*, ...}, ...]|из *image* [вырезается](#вырезка-нескольких-областей) множество подизображений, заданных спецификациями [*roi<sub>n</sub>*](#roi-83)|

[ImageTrim](#83-извлечение-областей-из-изображения) удаляет граничные пиксели из изображения. Обычно используется для извлечения интересующих областей.

#### Детализация и опции:

В качестве аргументов в функцию передаётся количество строк и/или столбцов относительно центра изображения, которые должны быть сохранены.
По умолчанию пиксели удаляются симметрично. 

<img align = 'center' style = 'max-width:200px' src = 'img/2/83a1.png' /> $\Rrightarrow$ <img align = 'center' style = 'max-width:200px' src = 'img/2/83a2.png' />

<div id = 'roi-83'></div>

##### *roi*-параметры:

|спецификация|описание|
|:-|:-|
|{{x<sub>1</sub>, y<sub>1</sub>}, ...}|[список](#вырезка-изображения-1го-пикселя) координат для 2D изображения|
|{{x<sub>1</sub>, y<sub>1</sub>, z<sub>1</sub>}, ...}|[список](#вырезка-объёмов-из-3d-изображения) координат для 3D изображения|
|*region*|2D или 3D геометрические [области](#вырезка-прямоугольной-области) ([Point](https://reference.wolfram.com/language/ref/Point.html?q=Point), [Disk](https://reference.wolfram.com/language/ref/Disk.html?q=Disk), [Sphere](https://reference.wolfram.com/language/ref/Sphere.html?q=Sphere), ...)|
|*maskimage*|2D или 3D [маска](#вырезка-по-маске) содержащая ненулевые пиксели - трафарет|
|*f*|область, заданная [функцией](#вырезка-заданной-функции) f|

<!--СДЕЛАТЬ ОБЩУЮ СПЕЦИФИКАЦИЮ ДЛЯ REGION-->

<div id = 'r-83'></div>

##### *r*-параметры:

|спецификация|описание|
|:-|:-|
|*r*|[марджин](#margin-83) со всех сторон|
|{*r<sub>x</sub>*, *r<sub>y</sub>*}|разный марджин по-вертикали и по-горизонтали|

###### опции по умолчанию:

|опция|описание опции|стандартное значение|
|:-|:-|:-|
|[DataRange](https://reference.wolfram.com/language/ref/DataRange.html?q=DataRange)|обрабатываемая [область](#datarange-83) *image*|[Full](https://reference.wolfram.com/language/ref/Full.html?q=Full)|
|[Padding](https://reference.wolfram.com/language/ref/Padding.html?q=Padding)|По умолчанию, если существует меньше элементов, чем требуется, [ImageTrim](#83-извлечение-областей-из-изображения) изображения будет возвращать только те элементы, которые присутствуют. Эта [настройка](#padding-83) позволит задать схему заполнения пикселей за пределами исходного изображения|[None](https://reference.wolfram.com/language/ref/None.html?q=None)|

<!--СДЕЛАТЬ ОБЩУЮ СПЕЦИФИКАЦИЮ ДЛЯ DATARANGE-->

#### Примеры:

##### фотография улиток:

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/83b1.png' />;
 
    ImageDimensions[i]

`Out[]:`

    {319, 302}

###### вырезка изображения 1го пикселя:

    ImageTrim[i, {140, 30}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83b2.png' />

###### вырезка области изображения по заданным координатам:

    ImageTrim[i, {{160, 10}, {70, 120}}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83b3.png' />

###### вырезка прямоугольной области:

    ImageTrim[i, Rectangle[{220, 20}, {140, 90}]]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83b4.png' />

<div id = 'margin-83'></div>

###### это эквивалентно случаю, когда маржа r = 0

    ImageTrim[i, Rectangle[{220, 20}, {140, 90}], 0]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83b5.png' />

###### cлучай когда маржа r $\not =$ 0:

    ImageTrim[i, Rectangle[{220, 20}, {140, 90}], 40]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83b6.png' />

###### вырезка по маске:

`ImageTrim[i, `<img align = 'center' style = 'max-width:200px' src = 'img/2/83b7.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83b8.png' />

###### вырезка заданной функции:

    ImageTrim[i, PixelValuePositions[#, White, .4] &]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83b9.png' />

###### вырезка нескольких областей:

    ImageTrim[i, {Rectangle[{220, 20}, {140, 90}], Rectangle[{300, 100}, {140, 300}]}]

`Out[]:` {<img align = 'center' style = 'max-width:200px' src = 'img/2/83b10.png' />, <img align = 'center' style = 'max-width:200px' src = 'img/2/83b11.png' />}

###### обрезка области вокруг максимума:

    ImageTrim[i, ImageValuePositions[#, "Max"] &, 140]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83b12.png' />

##### фотография лошади:

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/83c1.png' />;

###### вырезка объекта заданного цвета:

    ImageTrim[i, ImageValuePositions[i, White, .2], 10]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83c2.png' />

##### фотография птицы:

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/83d1.png' />;

###### обрезка областей, не содержащих ключевых точек:

    ImageTrim[i, ImageKeypoints[#, "KeypointStrength" -> .0001] &]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83d2.png' />

###### обрезка с маржой вокруг извлекаемых ключевых точек:

    ImageTrim[i, ImageKeypoints[#, "KeypointStrength" -> .0001] &, 20]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83d3.png' />

##### 3D фигуры:

`im3D = `<img align = 'center' style = 'max-width:200px' src = 'img/2/82d1.png' />;

###### вырезка объёмов из 3D-изображения:

    ImageTrim[im3D, {{1, 1, 15}, {46, 46, 17}}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83e2.png' />

    ImageTrim[im3D, {Cuboid[{0, 0, 0}, {23, 23, 23}], Cuboid[{23, 23, 23}, {0, 46, 46}]}]

`Out[]:` {<img align = 'center' style = 'max-width:200px' src = 'img/2/83e3.png' />, <img align = 'center' style = 'max-width:200px' src = 'img/2/83e4.png' /> }

##### 3D реконструкция колена: Создание и вырезка маски:

    knee = ExampleData[{"TestImage3D", "MRknee"}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83f1.png' />

###### маска кости колена:

    roi = `DeleteSmallComponents[Erosion[Binarize[knee], 3]]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83f2.png' />

###### кость и мышцы вокруг:

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83f3.png' />

###### кость без мышц

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83f4.png' />

##### фотография собаки:

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/83g1.png' />;

###### обрезка списка координат идентична использованию их границ:

    crds = {{90, 250}, {138, 62}, {189, 19}, {193, 133}, {191, 16}, {136, 16}, {177, 150}, {190, 200}, {200, 250}, {300, 250}};
    ImageTrim[i, crds]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/83g2.png' />

вычисление координат границы:

    bounds = Transpose[CoordinateBounds[coords]];
    ImageTrim[i, coords] == ImageTrim[i, bounds]

`Out[]:`
    
    True

###### вырезка морды алабая:

    i2 = ImageTrim[i, crds];
    ImageTrim[i2, FindFaces[i2]]

`Out[]:` {<img align = 'center' style = 'max-width:200px' src = 'img/2/83g4.png' />}

#### Опции:

<div id = 'datarange-83'></div>

##### [DataRange]() <!--ссылка на Datarange-->

Удаление пикселей с каждой стороны с применением стандартной системы [Image Coordinates](#72-image-coordinates), что эквивалентно [DataRange]() <!--ссылка на Datarange--> -> [Full]() <!--ссылка на Full-->

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/83h1.png' />;

    {ImageTrim[i, {{30, 30}, {170, 90}}], ImageTrim[i, {{30, 30}, {170, 90}}, DataRange -> Full]}

`Out[]:` {<img align = 'center' style = 'max-width:200px' src = 'img/2/83h2.png' />, <img align = 'center' style = 'max-width:200px' src = 'img/2/83h3.png' />}

<div id = 'padding-83'></div>

##### [Padding]() <!--ссылка на Padding-->

По умолчанию результирующие изображения имеют заданный размер и не заполняются, чтобы включить координаты целого исходного изображения. 
При указании опции [Padding]() <!--ссылка на Padding--> размер полученного изображения увеличивается через соответствующее заполнение.

    {ImageTrim[i, {{80, 70}, {250, 200}}], ImageTrim[i, {{80, 70}, {250, 200}}, Padding -> Red]}

`Out[]: {`<img align = 'center' style = 'max-width:200px' src = 'img/2/83h4.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img/2/83h5.png' />`}`

### 8.4 Расширение изображения на границах

|функция|описание|
|:-|:-|
|[ImagePad](https://reference.wolfram.com/language/ref/ImagePad.html?q=ImagePad)[*image*, *m*]|[обрамление](#лев-1) *image* со всех сторон из *m* пикселей фона|
|[ImagePad](https://reference.wolfram.com/language/ref/ImagePad.html?q=ImagePad)[*image*, *m*, *paddingSpec*]|обрамление *image* со всех сторон из *m* пикселей соответственно заданной параметры [*paddingSpec*](#примеры-paddingspec)|
|[ImagePad](https://reference.wolfram.com/language/ref/ImagePad.html?q=ImagePad)[*image*, {{*left*, *right*}, {*bottom*, *top*}}, ...]|[обрамление](#примеры-paddingspec) 2D *image* с каждой стороны соответственно заданным количеством пикселей|
|[ImagePad](https://reference.wolfram.com/language/ref/ImagePad.html?q=ImagePad)[*image*, {{*left*, *right*}, {*front*, *back*}, {*bottom*, *top*}}, ...]|[обрамление](#расширение-3d-2) 3D *image* с каждой стороны соответственно заданным количеством пикселей|

[ImagePad](#84-расширение-изображения-на-границах) ообычно используется для добавления рамки вокруг изображения или его расширения согласно заданной [функции](#textureSync-84).

Если аргумент [*m*](#84-расширение-изображения-на-границах) < 0, то пиксели не добавляются, а удаляются

##### изображение льва:

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/84a1.png' />;

##### лев 1:

    ImagePad[i, 10]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84a2.png' />

#### Детализация и опции:

[ImagePad](#84-расширение-изображения-на-границах) поддерживает все наиболее распространенные методы заполнения [*padding*]()<!--ссылка на padding-->.
Заполнение бинарного изображения пикселями произвольной интенсивности или цвета обычно возвращает изображение реального типа.

#### Примеры:

##### примеры paddingSpec:

`ImagePad[`<img align = 'center' style = 'max-width:200px' src = 'img/2/84b1.png' />`, {{80, 80}, {80, 80}}, #]& /@ {0, 0.5, Red, {.2, .8, .2}, "Fixed", "Reflected", "Periodic", "Reversed", "TextureSynthesis"}, 3]`

|значение #|`Out[]:`|
|:-|:-|
|0|<img align = 'center' style = 'max-width:200px' src = 'img/2/84b2.png' />|
|0.5|<img align = 'center' style = 'max-width:200px' src = 'img/2/84b3.png' />|
|Red|<img align = 'center' style = 'max-width:200px' src = 'img/2/84b4.png' />|
|{.2, .8, .2}|<img align = 'center' style = 'max-width:200px' src = 'img/2/84b5.png' />|
|"Fixed"|<img align = 'center' style = 'max-width:200px' src = 'img/2/84b6.png' />|
|"Reflected"|<img align = 'center' style = 'max-width:200px' src = 'img/2/84b7.png' />|
|"Periodic"|<img align = 'center' style = 'max-width:200px' src = 'img/2/84b8.png' />|
|"Reversed"|<img align = 'center' style = 'max-width:200px' src = 'img/2/84b9.png' />|
|"TextureSynthesis"|<img align = 'center' style = 'max-width:200px' src = 'img/2/84b10.png' />|

##### расширение 3D изображения:

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/84c1.png' />;

###### расширение 3D 1:

    ImagePad[i, 5]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84c2.png' />

###### расширение 3D 2:

    ImagePad[i, {{0, 0}, {0, 0}, {10, 10}}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84c3.png' />

###### расширение 3D 3:

    ImagePad[i, 1, Red]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84c4.png' />

###### расширение 3D 4:

    ImagePad[i, 4, "Periodic"]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84c5.png' />

<div id = 'padding-84'></div>

#### параметры padding:

##### одноцветная граница:

Если граница изображения единого цвета, он используется для автоматического заполнения.

`ImagePad[`<img align = 'center' style = 'max-width:200px' src = 'img/2/82e1.png' />`, 20, Automatic]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84d2.png' />

<div id = 'textureSync-84'></div>

##### TextureSynthesis: заполнение синтетической текстурой

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/84e1.png' />

    ImagePad[i, 15, "TextureSynthesis"]

###### базовое синтезирование текстуры:

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84e2.png' />

###### заполнение шириной 10 пикселей

    ImagePad[i, 30, {"TextureSynthesis", 10}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84e3.png' />

###### заполнение элементами текстуры из заданной доли размера пикселя с каждой стороны

    ImagePad[i, 50, {"TextureSynthesis", Scaled[0.25]}]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84e4.png' />

###### для синтеза текстуры для границы используется изображение бабочки

`ImagePad[i, 30, {"TextureSynthesis", `<img align = 'center' style = 'max-width:200px' src = 'img/2/84e5.png' />`}]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84e6.png' />

По умолчанию синтез текстур может выбирать любые пиксели изображения.
Это может привести к появлению нежелательных деталей лучшая пркатика избегания которых &mdash; указывание маски.

``i = ``<img align = 'center' style = 'max-width:200px' src = 'img/2/84f1.png' />

|`In[]`|тип|`Out[]`|
|:-|:-|:-|
|`ImagePad[i, 40, "TextureSynthesis"]`|без маски|<img align = 'center' style = 'max-width:200px' src = 'img/2/84f3.png' />|
|`ImagePad[i, 40, {"TextureSynthesis", `<img align = 'center' style = 'max-width:200px' src = 'img/2/84f2.png' />`}]`|с маской|<img align = 'center' style = 'max-width:200px' src = 'img/2/84f4.png' />|

#### Взаимосвязь с другими WM-функциями:

##### Как убрать ненужный фрагмент:

[Заполнение](#texturesynthesis-заполнение-синтетической-текстурой) синтетической текстурой лишь увеличивает границу. Чтобы убрать ненужный фрагмент используют функцию [Inpaint](https://reference.wolfram.com/language/ref/Inpaint.html?v=14.1) и маску.

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/84g1.png' />;

`ImagePad[i, 5, "TextureSynthesis"]`

`Inpaint[i, `<img align = 'center' style = 'max-width:200px' src = 'img/2/84g3.png' />`]`

`Out[1]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84g2.png' />

`Out[2]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/84g4.png' />

##### Функции возвращающие аналогичный результат

|вид|`In[]:`|`Out[]:`|
|:-|:-|:-|
|[ImagePad](#84-расширение-изображения-на-границах)[*image*, {{*left*, *right*}, {*bottom*, *top*}}]|`ImagePad[`<img align = 'center' style = 'max-width:100px' src = 'img/2/84b1.png' />`, {{40, 40}, {-20, -20}}, Padding -> Yellow]`|<img align = 'center' style = 'max-width:100px' src = 'img/2/84h2.png' />|
|[ImageCrop](#82-удаление-граничных-пикселей-из-изображения)[*image*, {*width*, *height*}]|`ImageCrop[`<img align = 'center' style = 'max-width:100px' src = 'img/2/84b1.png' />`, `ImageDimensions[<img align = 'center' style = 'max-width:100px' src = 'img/2/84h2.png' />]`, Padding -> Yellow]`|<img align = 'center' style = 'max-width:100px' src = 'img/2/84h3.png' />|

## 9. Изменение положения и размеров изображения через пересчет

### 9.1 Изменение размерности изображения

|функция|возвращает|
|:-|:-|
|[ImageResize](https://reference.wolfram.com/language/ref/ImageResize.html?q=ImageResize)[*image*, *width*]|[измененная](#изображение-размером-100-пикселей) версия *image* шириной [*width*](#spec-91) пикселей|
|[ImageResize](https://reference.wolfram.com/language/ref/ImageResize.html?q=ImageResize)[*image*, {*size*}]|[измененная](#увеличение-размерности-изображения-так-чтобы-размер-не-превышал-300-пикселей) версия *image*, максимальная [ширина](#spec-91) или [высота](#spec-91) которого в пикселях задана *size*|
|[ImageResize](https://reference.wolfram.com/language/ref/ImageResize.html?q=ImageResize)[image, {*width*, *height*}]|измененная версия *image* с точно заданной [шириной](#spec-91) и [высотой](#spec-91) в пикселях|
|[ImageResize](https://reference.wolfram.com/language/ref/ImageResize.html?q=ImageResize)[*image*, {*width*, *depth*, *height*}]|измененная версия 3D *image* с заданными [размерами](#spec-91)|

[Функция](#91-изменение-размерности-изображения) используется для увеличения размера или создания миниатюр при предварительном просмотре коллекции изображений, для стандартизации размера коллекций изображений при пакетной обработке, обучении и т.д.

`ImageResize[`<img align = 'center' style = 'max-width:200px' src = 'img/2/91a1.png' />`, Scaled[#]]& /@ {1/4, 1/3, 1, 3/2}`

|значение #|`Out[]:`|
|:-|:-|
|`1/4`|<img align = 'center' style = 'max-width:200px' src = 'img/2/91a2.png' />|
|`1/3`|<img align = 'center' style = 'max-width:200px' src = 'img/2/91a3.png' />|
|`1`|<img align = 'center' style = 'max-width:200px' src = 'img/2/91a4.png' />|
|`3/1`|<img align = 'center' style = 'max-width:200px' src = 'img/2/91a5.png' />|

#### Детализация и опции:

<div id = 'spec-91'></div>

##### параметры *width*, *depth*, *height*:

|возможное значение|описание|
|:-|:-|
|*d*|*d* [пикселей](#изображение-размером-100-пикселей)|
|{*d*}|[максимум](#увеличение-размерности-изображения-так-чтобы-размер-не-превышал-300-пикселей) *d* пикселей|
|[Scaled](https://reference.wolfram.com/language/ref/Scaled.html)[*s*]|оригинальный [размер](#масштабированное-изображение) * *s*|
|[All](https://reference.wolfram.com/language/ref/All.html?q=All)|оригинальный [размер](#изменение-размерности-изображения-в-одном-направлении)|
|[Automatic](https://reference.wolfram.com/language/ref/Automatic.html?q=Automatic)|в соответствии с [пропорциями](#изменение-размерности-изображения-с-сохранением-соотношения-сторон)|
|[Tiny](https://reference.wolfram.com/language/ref/Tiny.html?q=Tiny), [Small](https://reference.wolfram.com/language/ref/Small.html?q=Small), [Medium](https://reference.wolfram.com/language/ref/Medium.html?q=Medium), [Large](https://reference.wolfram.com/language/ref/Large.html?q=Large)|[стандартизированный размер](<!--стандартизированный-->)|

<!--Scaled link-->
<!--Tiny link-->

[ImageResize](#91-изменение-размерности-изображения)[*image*, *width*] и [ImageResize](#91-изменение-размерности-изображения)[*image*, {*size*}] сохраняют исходное соотношение сторон изображения.

[ImageResize](#91-изменение-размерности-изображения)[*image*, {1, *r*}] возвращает изображение с соотношением сторон *width* x *height* * *r*.

[ImageResize](#91-изменение-размерности-изображения)[*image*, *width*] аналогична [ImageResize](#91-изменение-размерности-изображения)[*image*, {*width*, Automatic}]

[ImageResize](#91-изменение-размерности-изображения)[*image*, {*size*}] аналогична [ImageResize](#91-изменение-размерности-изображения)[*image*, {{*size*},{*size*}}] 

##### опции с установками по умолчанию:

||||
|:-|:-|:-|
|[Padding]()|"Reversed"|тип [заполнения](#padding-91) исходного изображения|
|[Resampling](https://reference.wolfram.com/language/ref/Resampling.html?q=Resampling)|[Automatic]()|[метод](#resampling) интерполяции|

<!--Padding-->
<!--Automatic-->

##### [Resampling](https://reference.wolfram.com/language/ref/Resampling.html):

Параметр [Resampling](https://reference.wolfram.com/language/ref/Resampling.html) используется для выбора метода которым будет происходить передискретихация для нового изображения.

При использовании константы значение заполнения функцией [Resampling](#resampling) преобразуется в цветовое пространство целевого изображения.

<!--Вопрос-->

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/resampling1.png' />`;`

     ImageResize[i, {6, 6}, Resampling -> "Linear", Padding -> 1]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/resampling2.png' />

    ImageResize[i, {10, 10}, Resampling -> "Linear", Padding -> #] & /@ {Black, "Fixed", "Periodic", "Reflected"}

|значение #|`Out[]:`|
|:-|:-|
|`Black`|<img align = 'center' style = 'max-width:200px' src = 'img/2/resampling3.png' />|
|`"Fixed"`|<img align = 'center' style = 'max-width:200px' src = 'img/2/resampling4.png' />|
|`"Periodic"`|<img align = 'center' style = 'max-width:200px' src = 'img/2/resampling5.png' />|
|`"Reflected"`|<img align = 'center' style = 'max-width:200px' src = 'img/2/resampling6.png' />|

[Resampling](<!--Resampling-->) &rarr; "Nearest" отменяет установки опции [Padding](<!--Padding-->).

    ImageResize[i, {10, 10}, Resampling -> "Linear"]
    ImageResize[i, {10, 10}, Resampling -> "Linear", Padding -> 5]
    ImageResize[i, {10, 10}, Resampling -> "Nearest"]
    ImageResize[i, {10, 10}, Resampling -> "Nearest", Padding -> 5]

`Out[1]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/resampling-b1.png' />

`Out[2]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/resampling-b2.png' />

`Out[3]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/resampling-b3.png' />

`Out[4]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/resampling-b4.png' />

[Resampling](<!--Resampling-->) &rarr; "Linear" используется при увеличении размера изображения.

    ImageResize[i, Scaled[3]]
    ImageResize[i, Scaled[3], Resampling -> "Linear"]

`Out[1]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/resampling7.png' />

`Out[2]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/resampling8.png' />

[Resampling](<!--Resampling-->) &rarr; "Lanczos" используется при уменьшении размера изображения.

    ImageResize[i, Scaled[1/2], Resampling -> "Lanczos"
    ImageResize[i, Scaled[1/2], Resampling -> "Nearest"]


`Out[1]: `<img align = 'center' style = 'max-width:200px' src = 'img/2/resampling9.png' />

`Out[2]: `<img align = 'center' style = 'max-width:200px' src = 'img/2/resampling10.png' />

#### Примеры:

##### изменение размерности цветного 2D изображения:

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/91b1.png' />`;`

    ImageDimensions[i]

`Out[]:`
    
    {224, 225}

###### изображение размером 100 пикселей:

    ImageResize[i, 100]
    ImageDimensions[%]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/91b2.png' />

`Out[2]:`

    {100, 100}

###### масштабированное изображение:

    ImageResize[i, Scaled[1/2]]
    ImageDimensions[%]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/91b3.png' />

`Out[2]:`

    {112, 113}

###### изменение размерности изображения с сохранением соотношения сторон:

    ImageResize[i, {Automatic, 150}]
    ImageDimensions[%]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/91b4.png' />

`Out[2]:`

    {149, 150}

###### изменение размерности изображения с помощью встроенных установок на стандартизированный размер:

    ImageResize[i, Large]
    ImageDimensions[%]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/91b5.png' />

`Out[2]:`

    {448, 450}

###### увеличение размерности изображения так, чтобы размер не превышал 300 пикселей:

    ImageResize[i, {300}]
    ImageDimensions[%]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/91b6.png' />

`Out[2]:`
    
    {299, 300}

###### изменение размерности изображения по заданным размерам:

    ImageResize[i, {100, 50}]
    ImageDimensions[%]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/91b7.png' />

`Out[2]:`
  
    {100, 50}

###### изменение размерности изображения в одном направлении:

    ImageResize[i, {All, 50}]
    ImageDimensions[%]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/91b7.png' />

`Out[2]:`

    {224, 50}

##### изменение размерности 3D изображения:

`im3D =`<img align = 'center' style = 'max-width:200px' src = 'img/2/81d1.png' />`;`

    ImageDimensions[im3D]

`Out[]:`

    {64, 64, 50}

###### базовое изменение размерности 3D изображения:

    ImageResize[im3D, 32]
    ImageDimensions[%]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/91c2.png' />

`Out[2]:`

    {32, 32, 25}

###### изменение размерности 3D изображения только по высоте:

    ImageResize[im3D, {Automatic, Automatic, 7}]
    ImageDimensions[%]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img/2/91c2.png' />

`Out[2]:`

    {64, 64, 10}

##### интерактивное изменение размерности:

`image = `<img align = 'center' style = 'max-width:200px' src = 'img/2/91d1.png' />`;`

    Manipulate[ImageResize[ImageTrim[image, pt, radius, Padding -> Gray], 200], {{pt, ImageDimensions[image]/2}, {1, 1}, ImageDimensions[image]}, {{radius, 200}, 50, 400}]

Скриншоты получившегося [Manipulate](<!--Manipulate-->):

<img align = 'center' style = 'max-width:200px' src = 'img/2/91d2.png' />

<img align = 'center' style = 'max-width:200px' src = 'img/2/91d3.png' />

#### Опции:

<div id = 'padding-91'></div>

##### [Padding](<!--Padding-->):

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/91a1.png' />`;`

###### заполнение константой:

    ImageResize[i, Scaled[3], Padding -> 1]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/91e2.png' />

##### [Resampling](#resampling) примеры:

    ImageResize[i, Scaled[1/5], Resampling -> "Lanczos"]
    ImageResize[i, Scaled[1/5], Resampling -> "Nearest"]

`Out[1]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/91e3.png' />

`Out[2]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/91e4.png' />

#### Применение:

##### Создание классификатора для списка изображений бактерий и грибов разного размера:

`examples = <|"mushroom" -> {`
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f1.png' />`, `
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f2.png' />`, `
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f3.png' />`, `
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f4.png' />`, `
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f5.png' />`}, "microbe" -> {`
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f6.png' />`, `
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f7.png' />`, `
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f8.png' />`, `
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f9.png' />`, `
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f10.png' />`}|>`

Необходимо стандартизировать список, вычислив средний размер.

###### нахождение среднего размера:

    dims = Round@Mean[ImageDimensions /@ Flatten[Values[examples]]]

`Out[]:`

    {379, 294}

###### стандартизация:

    conformed = Map[Image[ImageResize[#, dims], ImageSize -> 40] &, examples, {2}]

`Out[]: <|"mushroom" -> {`<img align = 'center' style = 'max-width:200px' src = 'img/2/91f11.png' />`, `
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f12.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img/2/91f13.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img/2/91f14.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img/2/91f15.png' />`}, "microbe" -> {`<img align = 'center' style = 'max-width:200px' src = 'img/2/91f16.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img/2/91f17.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img/2/91f18.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img/2/91f19.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img/2/91f20.png' />`}|>`

###### создание классификатора:

    mushmic = Classify[conformed]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/91f21.png' />

###### тест классификатора:

`mushmic[{`
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f6.png' />`, `
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f10.png' />`, `
<img align = 'center' style = 'max-width:200px' src = 'img/2/91f2.png' />`}]`

`Out[]:`

    {"microbe", "microbe", "mushroom"}

#### Взаимосвязь с другими WM-функциями:

##### [ImageTransformation](https://reference.wolfram.com/language/ref/ImageTransformation.html?q=ImageTransformation):

Использование в качестве аргумента [size](#91-изменение-размерности-изображения) [ImageTransformation](<!--ImageTransformation-->) получают эффект, аналогичный [ImageTransformation](<!--ImageTransformation-->).

i = <img align = 'center' style = 'max-width:200px' src = 'img/2/91g1.png' />`;`

    res1 = ImageTransformation[i, RotationTransform[10°], 100]
    res2 = ImageResize[ImageTransformation[i, RotationTransform[10 °]], 100, Resampling -> "Linear"]
    res1 == res2

`Out[1]: `<img align = 'center' style = 'max-width:200px' src = 'img/2/91g2.png' />

`Out[2]: `<img align = 'center' style = 'max-width:200px' src = 'img/2/91g3.png' />

`Out[3]:`
    
    True

##### [Thumbnail](#92-уменьшение-изображения):

Использовании предопределённого размера возвращает результат аналогичный результату [Thumbnail](#92-уменьшение-изображения)

i = <img align = 'center' style = 'max-width:200px' src = 'img/2/91h1.png' />`;`

    Thumbnail[i] == ImageResize[i, Small, Padding -> "Fixed"]

`Out[]:`

    True

##### [Import](<!--Import>):

    ImageResize[Import["ExampleData/rose.gif"], Medium]

`Out[]: `<img align = 'center' style = 'max-width:200px' src = 'img/2/91i1.png' />

    Import["ExampleData/rose.gif", ImageSize -> Medium] == ImageResize[Import["ExampleData/rose.gif"], Medium]

`Out[]:`

    True

### 9.2 Уменьшение изображения>

|функция|описание|
|:-|:-|
|[Thumbnail](https://reference.wolfram.com/language/ref/Thumbnail.html)[*image*]|уменьшенная [версия](#ex1-92) *image*|
|[Thumbnail](https://reference.wolfram.com/language/ref/Thumbnail.html)[*file*]|[миниатюра](#ex2-92) изображения, хранящегося в файле [*file*](#import-параметры)|
|[Thumbnail](https://reference.wolfram.com/language/ref/Thumbnail.html)[*url*]|[миниатюра](#ex3-92) изображения, хранящегося по [*url*-адресу](#import-параметры)|
|[Thumbnail](https://reference.wolfram.com/language/ref/Thumbnail.html)[*spec*, *size*]|миниатюра с заданным максимальным размером [*size*](#size-92) пикселя|

[Thumbnail](#92-уменьшение-изображения) используется для создания миниатюрной версии изображения.

`i = `<img align = 'center' style = 'max-width:200px' src = 'img/2/92a1.png' />

    it = Thumbnail[i]
    {ImageDimensions[i], ImageDimensions[it]}

`Out[1]: `<img align = 'center' style = 'max-width:200px' src = 'img/2/92a2.png' />

`Out[2]:`

    {{363, 272}, {150, 112}}

#### Детализация и опции:

[Thumbnail](#92-уменьшение-изображения)
- принимает 2D и 3D изображения
- возвращает **RGB** изображение

##### [Import](<!--Import-->) параметры:

|спецификация|доступные значения|
|:-|:-|
|*file*|[File](<!--File-->)[*"filename"*] или *"filename"*
|*url*|[URL](<~--url-->)[*"url"*] или *"url"*|

Для форматов изображений, таких как **JPEG**, **PNG** и **TIFF**, допускающих **тайловый рендеринг**<!--???-->, считываются только необходимые части файлов, что позволяет создавать миниатюры даже для изображений, [которые не поместились](#импорт-миниатюры-очень-большого-изображения-с-помощью-url) бы в доступной памяти.
Для многокадровых (например **GIF**) изображений создаётся список миниатюр, по одной для каждого кадра.

<div id = 'size-92'></div>

##### size-параметры:

|спецификация|доступные значения|
|:-|:-|
|n|n пикселей в ширину и высоту|
|UpTo[n]|до n пикселей в ширину и высоту|
|Tiny, Small, Medium, Large|[стандартные размеры](<!--стандартные размеры-->)|

##### опции с установками по умолчанию:

|опция|установка по умолчанию|описание|
|:-|:-|:-|
|[Background](<!--Background-->)|[Automatic	](<!--Automatic	-->)|цвет фона при добавлении отступов|
|[IncludeMetaInformation	](<!--IncludeMetaInformation	-->)|[Automatic	](<!--Automatic	-->)|типы метаданных для включения|
|[Padding		](<!--Padding		-->)|[Automatic	](<!--Automatic	-->)|тип заполнения исходного изображения|

#### Примеры:

<div id = 'ex1-92'></div>

`Thumbnail[`<img align = 'center' style = 'max-width:200px' src = 'img/2/92b1.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img/2/92b2.png' />

##### получение миниатюр хранящихся изображений:

<div id = 'ex2-92'></div>

    filename = ExampleData[{"TestImage", "Apples"}, "FilePath"];
    Thumbnail[filename]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\92c.png' />

<div id = 'ex3-92'></div>

    Thumbnail[URL["http://exampledata.wolfram.com/coneflower.jpg"]]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\92d.png' />

##### импорт миниатюры очень большого изображения с помощью **URL**:

    file = "http://eoimages.gsfc.nasa.gov/images/imagerecords73000/73580/world.topo.bathy.200401.3x21600x10800.jpg";
    Import[file, "ImageSize"]
    fT = Thumbnail[file]
    ImageDimensions[fT]

`Out[1]:`

    {21600, 10800}

`Out[2]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\92e.png' />

`Out[3]:`

    {150, 81}

#### Опции:

##### [Background](<!--Background-->):

По умолчанию изображения дополняются белыми пикселями, если они меньше размера миниатюры. [Background](#background) позволяет указать цвет отступа.

`i = `<img align = 'center' style = 'max-width:200px' src = 'img\2\92f1.png' />

    {Thumbnail[i, Medium], Thumbnail[i, Medium, Background -> Red]}

`Out[]:` `{`<img align = 'center' style = 'max-width:200px' src = 'img\2\92f2.png' />, <img align = 'center' style = 'max-width:200px' src = 'img\2\92f3.png' />`}`

##### [Padding](<!--Padding-->):

Избежать [автоматического добавления отступа](#background) можно, задав `Padding -> None`.

    Thumbnail[i, Medium, Padding -> None]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\92f4.png' />

#### Взаимосвязь с другими WM-функциями:

##### [ImageResize](#91-изменение-размерности-изображения):

Аналогичный [результат](#thumbnail).

`ImageResize[`<img align = 'center' style = 'max-width:200px' src = 'img\2\92a1.png' />`, Small]`

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\92g2.png' />

##### [Import](<!--Import -->):

Аналогичный результат.

    Import["ExampleData/rose.gif", ImageSize -> 50]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\92h.png' />

##### [ExampleData](<!--ExampleData-->):

`"Thumbnail"` может служить опцией при импорте [ExampleData](<!--ExampleData-->).

    ExampleData[{"TestImage", "Apples"}, "Thumbnail"]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\92i.png' />

### 9.3 Реверс изображения

|функция|описание|
|:-|:-|
|[ImageReflect](https://reference.wolfram.com/language/ref/ImageReflect.html?q=ImageReflect)[*image*]|[отражение](#отражение) *image* через зеркальное отражение сверху вниз|
|[ImageReflect](https://reference.wolfram.com/language/ref/ImageReflect.html?q=ImageReflect)[*image*, *side*]|[отражение](#отражение-по-стороне) *image* таким образом, чтобы сторона [*side*](#side-93) переходила в противоположную.|
|[ImageReflect](https://reference.wolfram.com/language/ref/ImageReflect.html?q=ImageReflect)[*image*, *side<sub>1</sub>* &rarr; *side<sub>2</sub>*]|[отражение](#отражение-стороны) image таким образом, чтобы сторона [*side<sub>1</sub>*](#side-93) переходила в [*side<sub>2</sub>*](#side-93)|

`ImageReflect[`<img align = 'center' style = 'max-width:200px' src = 'img\2\93a1.png' />`]`

`ImageReflect[`<img align = 'center' style = 'max-width:200px' src = 'img\2\93a1.png' />`, Left]}`

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\93a2.png' />

`Out[2]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\93a3.png' />

#### Детализация и опции:

[ImageReflect](https://reference.wolfram.com/language/ref/ImageReflect.html?q=ImageReflect) возвращает изображение со значениями пикселей, соответствующими исходному изображению.
Возвращаемое изображение отражается по линии, проходящей через его центр.
Работает с 2D и 3D изображениями.

<div id = 'side-93'></div>

##### side-параметры:

|сторона|описание|2D|3D|
|:-|:-|:-|:-|
|[Left](<!--Left-->)|левая сторона|True|True|
|[Right](<!-->)|правая сторона|True|True|
|[Bottom](<!-->)|нижняя сторона|True|True|
|[Top](<!-->)|верхняя сторона|True|True|
|[Front](<!-->)|передняя сторона 3D изображения|False|True|
|[Back](<!-->)|задняя сторона 3D изображения|False|True|

#### Примеры:

`i = `<img align = 'center' style = 'max-width:200px' src = 'img\2\93b1.png' />`;`

##### отражение:

    ImageReflect[i]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\93b2.png' />

##### отражение по стороне:

    ImageReflect[i, Left]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\93b3.png' />`

##### отражение стороны:

    ImageReflect[i, Left -> Top]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\93b4.png' />`

##### все возможные повороты:

    sides = {Bottom, Left, Right, Top};
    named = #[[1]] -> #[[2]] & /@ Tuples[sides, 2]

`Out[]:`

    {{Bottom -> Bottom}, {Bottom -> Left}, {Bottom -> Right}, {Bottom -> Top}, {Left -> Bottom}, {Left -> Left}, {Left -> Right}, {Left -> Top}, {Right -> Bottom}, {Right -> Left}, {Right -> Right}, {Right -> Top}, {Top -> Bottom}, {Top -> Left}, {Top -> Right}, {Top -> Top}}

`TableForm[Partition[ImageReflect[`<img align = 'center' style = 'max-width:200px' src = 'img\2\93c1.png' />`, #] & /@ named, 4], TableHeadings -> {sides, sides}, TableAlignments -> Center]`

|`#1 -> #2`|Bottom|Left|Right|Top|
|:-:|:-:|:-:|:-:|:-:|
|Bottom|![11](img\2\93c11.png)|![12](img\2\93c12.png)|![13](img\2\93c13.png)|![14](img\2\93c14.png)|
|Left|![21](img\2\93c21.png)|![22](img\2\93c22.png)|![23](img\2\93c23.png)|![24](img\2\93c24.png)|
|Right|![31](img\2\93c31.png)|![32](img\2\93c32.png)|![33](img\2\93c33.png)|![34](img\2\93c34.png)|
|Top|![41](img\2\93c41.png)|![42](img\2\93c42.png)|![43](img\2\93c43.png)|![44](img\2\93c44.png)|

##### реверс 3D изображения:

`im3D =`<img align = 'center' style = 'max-width:200px' src = 'img\2\81d1.png' />`;`

    {ImageReflect[im3D], ImageReflect[im3D, Back -> Front]}

`Out[]: {`<img align = 'center' style = 'max-width:200px' src = 'img\2\93d2.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\93d3.png' />`}`

#### Взаимосвязь с другими WM-функциями:

##### [ImageTransformation](<!--ImageTransformation-->)[*image*, *f*]:

Аналогичный эффект.

`i = `<img align = 'center' style = 'max-width:200px' src = 'img\2\93a1.png' />`;`

    ImageReflect[i]
    ImageTransformation[i, ReflectionTransform[{0, 1}], PlotRange -> All]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\93e2.png' />

`Out[2]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\93e3.png' />

### 9.4 Поворот изображения вокруг центра

|функция|описание|
|:-|:-|
|[ImageRotate](https://reference.wolfram.com/language/ref/ImageRotate.html)[*image*]|[поворот](#94-exa) *image* против часовой стрелки относительно точки вращения на 90°|
|[ImageRotate](https://reference.wolfram.com/language/ref/ImageRotate.html)[*image*, *θ*]|[поворот](#поворот-на-значение) *image* против часовой стрелки относительно точки вращения на *θ*°|
|[ImageRotate](https://reference.wolfram.com/language/ref/ImageRotate.html)[*image*, {*θ*, *w*}]|[поворот](#поворот-вокруг-главной-диагонали) 3D изображения вокруг 3D вектора *w* на *θ*°|
|[ImageRotate](https://reference.wolfram.com/language/ref/ImageRotate.html)[*image*, ..., *size*]|[поворот и обрезка](#обрезка-повёрнутого-изображения-по-размерам-исходного-изображения) изображения по [параметрам](size-94) *size*|
|[ImageRotate](https://reference.wolfram.com/language/ref/ImageRotate.html)[*image*, *side*]|[поворот](#поворот-указанной-стороны-изображения) изображения так, чтобы сторона *side* была наравлена наверх ([Top](<!-->) &rarr; [*side*](#side-94))|
|[ImageRotate](https://reference.wolfram.com/language/ref/ImageRotate.html)[*image*, *side<sub>1</sub>* &rarr; *side<sub>2</sub>*]|[поворот](#поворот-указанной-стороны-изображения) изображения так, чтобы сторона [*side<sub>1</sub>*](#side-94) была на месте [*side<sub>2</sub>*](#side-94)|

<div id = '94-exa'></div>

`ImageRotate[`<img align = 'center' style = 'max-width:200px' src = 'img\2\93a1.png' />`]`

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94a2.png' />

#### Детализация и опции:

<div id = 'side-94'></div>

##### side-параметры:

[Аналогичны](#side-93) side-параметрам [реверса изображения](#93-реверс-изображения) 

|сторона|описание|2D|3D|
|:-|:-|:-|:-|
|[Left](<!--Left-->)|левая [сторона](#поворот-указанной-стороны-изображения)|True|True|
|[Right](<!-->)|правая сторона|True|True|
|[Bottom](<!-->)|нижняя [сторона](#поворот-указанной-стороны-изображения)|True|True|
|[Top](<!-->)|верхняя [сторона](#поворот-указанной-стороны-изображения)|True|True|
|[Front](<!-->)|передняя сторона 3D изображения|False|True|
|[Back](<!-->)|задняя сторона 3D изображения|False|True|

<div id = 'size-94'></div>

##### size-параметры:

||описание|
|:-|:-|
|*width*|[обрезка](#обрезка-повёрнутого-изображения-по-указанной-ширине) изображения по ширине *width*|
|{*width*, *height*}|обрезка изображения по ширине *width* и высоте *height*|
|{*width*, *depth*, *height*}|обрезка 3D изображения по ширине *width*, глубине *depth* и высоте *height*|
|Automatic|обрезка изображения по наименьшему прямоугольнику, достаточному чтобы охватить повернутое изображение|
|All|[обрезка](#обрезка-повёрнутого-изображения-до-наименьшего-возможного-квадрата-который-вмещает-все-углы-поворота) изображения по наименьшему квадрату, достаточному чтобы охватить повернутое изображение при любом угле поворота|
|Full|[обрезка](#обрезка-повёрнутого-изображения-по-размерам-исходного-изображения) изображения по размерам исходного изображения|
|`"MaxAreaCropping"`|[обрезка](#обрезка-повёрнутого-изображения-по-размерам-исходного-с-максимизацией-площади) по размерам исходного изображения в пикселях с максимизацией площади|
|`"SameRatioCropping"`|[обрезка](#обрезка-повёрнутого-изображения-по-размерам-исходного-с-сохранением-пропорций) по размерам исходного изображения в пикселях с сохранением пропорций|

##### параметры с установками по умолчанию:

|параметр|значение по умолчанию|описание|
|:-|:-|:-|
|Background|0|используется цвет фона|
|Masking|All|область которую нужно повернуть|
|Padding|0|заполнение вокруг изображения|
|Resampling|Automatic|метод повторной дискретизации|

##### возмодные значения Masking:

||описание|
|:-|:-|
|All|поворачивается всё исходное изображение|
|Full|поворачивается всё исходное изображение и заполнение|
|*mask*|поворачивается часть изображения определённая маской *mask*|

#### Примеры:

##### фото морской звезды:

`i = `<img align = 'center' style = 'max-width:200px' src = 'img\2\94b1.png' />`;`

###### поворот на значение:

   ImageRotate[i, 30°]
    ImageRotate[i, -π/6]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94b2.png' />

`Out[2]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94b3.png' />

###### обрезка повёрнутого изображения по размерам исходного изображения:

    ImageRotate[i, 30°, Full]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94b4.png' />

###### обрезка повёрнутого изображения по указанной ширине:

    ImageRotate[i, 30°, 200]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94b5.png' />

###### обрезка повёрнутого изображения по размерам исходного с сохранением пропорций:

    ImageDimensions[i]
    ImageRotate[i, 30°, "SameRatioCropping"]
    ImageDimensions[%]

`Out[1]:`

    {259, 194}

`Out[2]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94b6.png' />

`Out[3]:`

    {169, 127}

###### обрезка повёрнутого изображения по размерам исходного с максимизацией площади:

    ImageDimensions[i]
    ImageRotate[i, 30°, "MaxAreaCropping"]
    ImageDimensions[%]

`Out[1]:`

    {259, 194}

`Out[2]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94b7.png' />

`Out[3]:`

    {194, 112}

###### обрезка повёрнутого изображения до наименьшего возможного квадрата, который вмещает все углы поворота:

    ImageRotate[i, 5° All]
    ImageRotate[i, 45° All]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94b8.png' />

`Out[2]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94b9.png' />

##### поворот указанной стороны изображения:


`i = `<img align = 'center' style = 'max-width:200px' src = 'img\2\93b1.png' />`;`

    {ImageRotate[i, Bottom], ImageRotate[i, Top -> Bottom], ImageRotate[i, Left -> Bottom]}

`Out[]: {`<img align = 'center' style = 'max-width:200px' src = 'img\2\94c2.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\94c3.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\94c4.png' />`}`

##### 3D изображение: по умолчанию поворачивается вокруг оси z

`im3d = `<img align = 'center' style = 'max-width:200px' src = 'img\2\81d1.png' />`;`

    ImageRotate[im3D]
    ImageRotate[im3D, π/2]

`Out[1]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94d1.png' />

`Out[2]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94d2.png' />

###### поворот вокруг оси x:

    ImageRotate[im3D, {π/5, {1, 0, 0}}]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94d3.png' />

###### поворот вокруг главной диагонали:

    ImageRotate[im3D, {π/5, {1, 1, 1}}]

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\94d4.png' />

##### интерактивная модель поворота изображения с различными size-установками:

`Manipulate[ImageRotate[`<img align = 'center' style = 'max-width:200px' src = 'img\2\93b1.png' />`, θ, size, Background -> Black], {{θ, 0}, -π/2, π/2}, {size, {All, Full, "MaxAreaCropping"}}, ControlPlacement -> Top]`

скриншоты полученного интерактивного объекта

###### 9.4 All:

<img align = 'center' style = 'max-width:200px' src = 'img\2\94e1a.png' />
<img align = 'center' style = 'max-width:200px' src = 'img\2\94e1b.png' />

###### 9.4 Full:

<img align = 'center' style = 'max-width:200px' src = 'img\2\94e2a.png' />
<img align = 'center' style = 'max-width:200px' src = 'img\2\94e2b.png' />

###### 9.4 "MaxAreaCropping":

<img align = 'center' style = 'max-width:200px' src = 'img\2\94e3a.png' />
<img align = 'center' style = 'max-width:200px' src = 'img\2\94e3b.png' />

## 10. Арифметические операции с изображениями

`ImageAdd[ImageMultiply[`<img align = 'center' style = 'max-width:200px' src = 'img\2\93a1.png' />`, 2/3], ImageMultiply[`<img align = 'center' style = 'max-width:200px' src = 'img\2\93a3.png' />`, 2/3]]`

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\10c.png' />

### 10.1 Сложение изображений

|функция|описание|
|:-|:-|
|[ImageAdd](https://reference.wolfram.com/language/ref/ImageAdd.html?q=ImageAdd)[*image*, *x*]|[добавление](#добавление-указанной-величины-к-каждому-значению-канала) *x* к значению каждого канала *image*|
|[ImageAdd](https://reference.wolfram.com/language/ref/ImageAdd.html?q=ImageAdd)[*image<sub>1</sub>*, *image<sub>2</sub>*]|[сумма](#ex1-101) изображений так, чтобы каждый пикслель полученного изображения являлся соответственно суммой пикселей *image<sub>1</sub>* и *image<sub>2</sub>*|
|[ImageAdd](https://reference.wolfram.com/language/ref/ImageAdd.html?q=ImageAdd)[*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...]|[добавление](#сложение-нескольких-изображений) каждого *expr<sub>i</sub>* к *image*; *expr<sub>i</sub>* может быть изображением, числом или цветом|

<div id = 'ex1-101'></div>

`ImageAdd[`<img align = 'center' style = 'max-width:200px' src = 'img\2\101a1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\101a2.png' />`]`

`Out[]:`<img align = 'center' style = 'max-width:200px' src = 'img\2\101a.png' />

#### Детализация и опции:

- Работает с 2D и [3D](#сложение-3d-изображений) изображениями.
- В **бинарных** изображениях команда эффективно находит логическое [или](#сложение-бинарных-изображений-логическое-или) в значениях пикселей.

##### [ImageAdd](https://reference.wolfram.com/language/ref/ImageAdd.html?q=ImageAdd)[*image*, *x*] параметры:

- [Размерность](1_Характеристики_цифрового_изображения.md#4-характеристики-изображения) получаемого изображения соответствует размерности исходного

- Обычно результирующее изображение имеет тот же базовый тип данных, что и исходное: значения пикселей обрезаются или усекаются, если это необходимо

- возможные значения *x*:
    - [число](#добавление-указанной-величины-к-каждому-значению-канала), обычно находящееся в диапазоне [0, 1]
    - цвет
    - [список](#окраска-в-стиле-сепия-1) значений цветового канала

##### [ImageAdd](https://reference.wolfram.com/language/ref/ImageAdd.html?q=ImageAdd)[*image<sub>1</sub>*, *image<sub>2</sub>*] параметры:

- Если размерности *image<sub>1</sub>* и *image<sub>2</sub>* различны, *image<sub>2</sub>* прибавляется к центру *image<sub>1</sub>*.
- Если *image<sub>1</sub>* или *image<sub>2</sub>* - одноканальное изображения, значения его пикселей добавляются к значениям в каждом канале другого изображения.
- Если *image<sub>1</sub>* и *image<sub>2</sub>* - оба многоканальные изображения, значения в каждом канале добавляются по отдельности.
- Результат &mdash; изображение с типом данных наибольшего изображения. При этом происходит обрезка или усечение значений пикселей, если это необходимо.

##### [ImageAdd](https://reference.wolfram.com/language/ref/ImageAdd.html?q=ImageAdd)[*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...]

- сложние происходит согласно списку аргументов
- ImageAdd[*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...] аналогично ImageAdd[{*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...}]

##### Общие параметры:

На числовое округление конечной точности может влиять ограниченная точность машинной арифметики.

    ImageData[ImageAdd[Image[{{#}}, "Byte"], 0.5], Automatic] & /@ {35, 36}

`Out[]:`

    {{{163}}, {{164}}}

---

    ImageData[ImageAdd[Image[{{#}}, "Byte"], 1], Automatic] & /@ {35, 36}

`Out[]:`

    {{{255}}, {{255}}}

При добавлении изображений различных цветовых пространств значения каналов добавляются соответственно. Полученное изображение будет иметь цветовое пространство [Automatic](<!--Automatic-->).

    i1 = Image[{{{.1, .2, .3}}}, ColorSpace -> "RGB"]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101b1.png' />

    i2 = Image[{{{.1, .2, .3}}}, ColorSpace -> "LAB"]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101b2.png' />

    ImageAdd[i1, i2]
    % // ImageColorSpace

`Out[1]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101b3.png' />

`Out[2]:`

    Automatic

#### Примеры:

##### добавление указанной величины к каждому значению канала:

`ImageAdd[`<img align = 'center' style = 'max-width:200px' src = 'img\2\101c1.png' />`, 0.25]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101c2.png' />

##### сложение изображений двух цветов:

`ImageAdd[`<img align = 'center' style = 'max-width:200px' src = 'img\2\101d1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\101d2.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101d.png' />

##### сложение бинарных изображений: логическое "или"

`ImageAdd[`<img align = 'center' style = 'max-width:200px' src = 'img\2\101e1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\101e2.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101e.png' />

##### сложение изображения с маской объекта:

`ImageAdd[`<img align = 'center' style = 'max-width:200px' src = 'img\2\101f1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\101f2.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101f.png' />

##### сложение нескольких изображений:

`ImageAdd[`<img align = 'center' style = 'max-width:200px' src = 'img\2\101e1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\101g1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\101e2.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101g2.png' />

##### сложение 3D изображений:

`ImageAdd[`<img align = 'center' style = 'max-width:200px' src = 'img\2\101h1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\101h2.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101h.png' />

#### Применение:

##### раскраска изображения:

###### окраска в стиле сепия 1:

`ImageAdd[`<img align = 'center' style = 'max-width:200px' src = 'img\2\101i.png' />`, RGBColor[{0.44, 0.26, 0.08}]]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101i2.png' />

###### окраска в стиле сепия 1:

`image =`<img align = 'center' style = 'max-width:200px' src = 'img\2\101j.png' />`;`

    dims = ImageDimensions[image];
    ImageAdd[ColorConvert[image, "Grayscale"], RGBColor[{0.44, 0.26, 0.08}]]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101j2.png' />

##### создание эффекта виньетки:

    ImageMultiply[%, ImageAdjust[Image[Transpose@GaussianMatrix[{dims/2, dims/2}]]]]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101j3.png' />

#### Взаимосвязь с другими WM-функциями:

##### [ImageAdjust](<!--inageadjust-->):

При добавлении изображений целочисленных типов происходит отсечение значений пикселей.
Чтобы избежать обрезки, при использовании [ImageAdjust](<!--ImageAdjust-->) нужно использовать реальный тип изображения.

`images = {`<img align = 'center' style = 'max-width:200px' src = 'img\2\101a2.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\101k2.png' />`];`

    ImageAdd[images]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101k3.png' />

    ImageAdjust[%]

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101k4.png' />

    ImageAdd[Image[#, "Real"] & /@ images] // ImageAdjust

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\101k5.png' />

### 10.2 Вычитание изображений

|функция|описание|
|:-|:-|
|[ImageSubtract](https://reference.wolfram.com/language/ref/ImageSubtract.html?q=ImageSubtract)[*image*, *x*]|[вычитание](#вычитание-из-каждого-канала-постоянной-величины) *x* из каждого значения канала *image*|
|[ImageSubtract](https://reference.wolfram.com/language/ref/ImageSubtract.html?q=ImageSubtract)[*image<sub>1</sub>*, *image<sub>2</sub>*]|[получение](#вычитание-из-изображения-маски) изображения, в котором каждый пиксель является разностью соответствующих пикселей *image<sub>1</sub>* и *image<sub>2</sub>*|
|[ImageSubtract](https://reference.wolfram.com/language/ref/ImageSubtract.html?q=ImageSubtract)[*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...]|вычитание всех *expr<sub>i</sub>* из *image*, где каждый *expr<sub>i</sub>* может быть изображением, числом или цветом.|

`ImageSubtract[`<img align = 'center' style = 'max-width:200px' src = 'img\2\101d1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\101d2.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\102a.png' />

#### Детализация и опции:

- Работает с 2D и [3D](#вычитание-3d-изображений) изображениями.

##### [ImageSubtract](https://reference.wolfram.com/language/ref/ImageSubtract.html?q=ImageSubtract)[*image*, *x*] параметры:

- [Размерность](1_Характеристики_цифрового_изображения.md#4-характеристики-изображения) получаемого изображения соответствует размерности исходного

- Обычно результирующее изображение имеет тот же базовый тип данных, что и исходное: значения пикселей обрезаются или усекаются, если это необходимо

- возможные значения *x*:
    - [число](#вычитание-из-каждого-канала-постоянной-величины), обычно находящееся в диапазоне [0, 1]
    - [цвет](#вычитание-определённых-каналов-цвета)
    - список значений цветового канала

##### [ImageSubtract](https://reference.wolfram.com/language/ref/ImageSubtract.html?q=ImageSubtract)[*image<sub>1</sub>*, *image<sub>2</sub>*] параметры:

- Если размерности *image<sub>1</sub>* и *image<sub>2</sub>* различны, *image<sub>2</sub>* вычитается из цента *image<sub>1</sub>*.
- Если *image<sub>1</sub>* или *image<sub>2</sub>* - одноканальное изображения, значения его пикселей вычитаются из значений в каждом канале другого изображения.
- Если *image<sub>1</sub>* и *image<sub>2</sub>* - оба многоканальные изображения, значения в каждом канале вычитаются по отдельности.
- Результат &mdash; изображение с типом данных наибольшего изображения. При этом происходит обрезка или усечение значений пикселей, если это необходимо.

##### [ImageSubtract](https://reference.wolfram.com/language/ref/ImageSubtract.html?q=ImageSubtract)[*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...]

- вычитание происходит согласно списку аргументов
- ImageSubtract[*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...] аналогично ImageSubtract[{*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...}]

#### Примеры:

##### вычитание из изображения маски:

`ImageSubtract[`<img align = 'center' style = 'max-width:200px' src = 'img\2\102b1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\102b2.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\102b.png' />

##### вычитание из каждого канала постоянной величины:

`ImageSubtract[`<img align = 'center' style = 'max-width:200px' src = 'img\2\102c.png' />`, 0.25]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\102c2.png' />

##### вычитание 3D изображений:

`ImageSubtract[`<img align = 'center' style = 'max-width:200px' src = 'img\2\102d1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\102d2.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\102d3.png' />

##### вычитание определённых каналов цвета:

`ImageSubtract[`<img align = 'center' style = 'max-width:200px' src = 'img\2\102e.png' />`, #] & /@ {Cyan, Magenta, Yellow}`

`Out[]: {`<img align = 'center' style = 'max-width:200px' src = 'img\2\102e1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\102e2.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\102e3.png' />`}`

#### Применение:

<div id = 'ex1-102'></div>

##### создание нерезкой маски через вычитание размытой версии, и добавление её к исходному изображению:

`i =`<img align = 'center' style = 'max-width:200px' src = 'img\2\102f.png' />`;`

    ImageSubtract[i, MedianFilter[i, 10]]

 `Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\102f1.png' />

    ImageAdd[i, %]

 `Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\102f2.png' />

 ### 10.3 Умножение изображений

 |функция|описание|
|:-|:-|
|[ImageMultiply](https://reference.wolfram.com/language/ref/ImageMultiply.html?q=ImageMultiply)[*image*, *x*]|[умножение](#умножение-на-цвет) на *x* каждого значения канала *image*|
|[ImageMultiply](https://reference.wolfram.com/language/ref/ImageMultiply.html?q=ImageMultiply)[*image<sub>1</sub>*, *image<sub>2</sub>*]|[получение](#умножение-изображения-на-маску) изображения, в котором каждый пиксель является произведением соответствующих пикселей *image<sub>1</sub>* и *image<sub>2</sub>*|
|[ImageMultiply](https://reference.wolfram.com/language/ref/ImageMultiply.html?q=ImageMultiply)[*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...]|умножение *image* на все *expr<sub>i</sub>*, где каждый *expr<sub>i</sub>* может быть изображением, числом или цветом.|

`ImageMultiply[`<img align = 'center' style = 'max-width:200px' src = 'img\2\81f1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\103a2.png' />`]`

 `Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\103a3.png' />

#### Детализация и опции:

- Работает с 2D и 3D изображениями.
- В бинарных изображениях команда эффективно [находит](#умножение-бинарных-изображений) логическое "и" в значениях пикселей.

##### [ImageMultiply](https://reference.wolfram.com/language/ref/ImageMultiply.html?q=ImageMultiply)[*image*, *x*] параметры:

- [Размерность](1_Характеристики_цифрового_изображения.md#4-характеристики-изображения) получаемого изображения соответствует размерности исходного

- Обычно результирующее изображение [имеет](#умножение-на-цвет) тот же базовый тип данных, что и исходное: значения пикселей обрезаются или усекаются, если это необходимо

- При умножении изображения и цветов обычно [сохраняется](#умножение-на-цвет) тип данных входного изображения

- возможные значения *x*:
    - [число](#осветление-rgb-изображения-умножение-всех-пикселей-на-коэффициент), обычно находящееся в диапазоне [0, 1]
    - [цвет](#умножение-на-цвет)
    - список значений цветового канала

##### [ImageMultiply](https://reference.wolfram.com/language/ref/ImageMultiply.html?q=ImageMultiply)[*image<sub>1</sub>*, *image<sub>2</sub>*] параметры:

- Если размерности *image<sub>1</sub>* и *image<sub>2</sub>* различны, *image<sub>2</sub>* умножается с цента *image<sub>1</sub>*.
- Если *image<sub>1</sub>* или *image<sub>2</sub>* - одноканальное изображения, значения его пикселей [умножаются](#умножение-изображения-на-маску) на значения в каждом канале другого изображения.
- Если *image<sub>1</sub>* и *image<sub>2</sub>* - оба многоканальные изображения, значения в каждом канале умножаются по отдельности.
- Результат &mdash; изображение с типом данных наибольшего изображения. При этом происходит обрезка или усечение значений пикселей, если это необходимо.

##### [ImageMultiply](https://reference.wolfram.com/language/ref/ImageMultiply.html?q=ImageMultiply)[*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...]

- умножение происходит согласно списку аргументов
- ImageMultiply[*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...] аналогично ImageMultiply[{*image*, *expr<sub>1</sub>*, *expr<sub>2</sub>*, ...}]

#### Примеры:

##### умножение бинарных изображений:

`ImageMultiply[`<img align = 'center' style = 'max-width:200px' src = 'img\2\103b1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\103b2.png' />`]`

 `Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\103b3.png' />

 ##### умножение на цвет:

 `i = `<img align = 'center' style = 'max-width:200px' src = 'img\2\103c1.png' />`;`

    res = ImageMultiply[i, Orange]
    ImageType /@ {i, res}

 `Out[1]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\103c2.png' />

`Out[2]:`

    {"Byte", "Byte"}

##### умножение изображения на маску:

`ImageMultiply[`<img align = 'center' style = 'max-width:200px' src = 'img\2\103d1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\103d2.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\103d3.png' />

##### осветление RGB-изображениЯ: умножение всех пикселей на коэффициент

`ImageMultiply[`<img align = 'center' style = 'max-width:200px' src = 'img\2\101d2.png' />`, 1.5]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\103e.png' />

##### умножение 3D изображений:

`ImageMultiply[`<img align = 'center' style = 'max-width:200px' src = 'img\2\101h1.png' />`, Green]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\103f.png' />

##### окраска каналов изображения:

`MapThread[ImageMultiply, {ColorSeparate[`<img align = 'center' style = 'max-width:200px' src = 'img\2\103g1.png' />`], {Red, Green, Blue}}]`

`Out[]: {`<img align = 'center' style = 'max-width:200px' src = 'img\2\103g2.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\103g3.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\103g4.png' />`}`

#### Применение:

##### создании композиции из цветного изображения и изображения в серых тонах:

`ImageMultiply[`<img align = 'center' style = 'max-width:200px' src = 'img\2\103h1.png' />`, `<img align = 'center' style = 'max-width:200px' src = 'img\2\103h2.png' />`]`

`Out[]:` <img align = 'center' style = 'max-width:200px' src = 'img\2\103h3.png' />